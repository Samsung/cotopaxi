# -*- coding: utf-8 -*-
"""Tool for checking vulnerability of network service."""
#
#    Copyright (C) 2021 Cotopaxi Contributors. All Rights Reserved.
#    Copyright (C) 2020 Samsung Electronics. All Rights Reserved.
#       Authors: Jakub Botwicz, Michał Radwański
#
#    This file is part of Cotopaxi.
#
#    Cotopaxi is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 2 of the License, or
#    (at your option) any later version.
#
#    Cotopaxi is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with Cotopaxi.  If not, see <http://www.gnu.org/licenses/>.
#

import abc
import os
import socket
import sys

import yaml
from scapy.all import Packet
from scapy.contrib.coap import CoAP

from .common_utils import (
    amplification_factor,
    INPUT_BUFFER_SIZE,
    print_verbose,
    Protocol,
    show_verbose,
    UDP_LOW_LAYERS_HEADERS_SIZE_IPV4,
)
from .cotopaxi_tester import (
    CotopaxiTester,
    protocol_enabled,
    PROTOCOL_TESTERS,
    sr1_file,
)
from .service_ping import service_ping

VULN_DB_PATH = os.path.dirname(__file__) + "/vulnerabilities/"
VULN_DB_YAML = VULN_DB_PATH + "vulnerabilities.yaml"

# https://stackoverflow.com/a/38668373
ABC = abc.ABCMeta("ABC", (object,), {"__slots__": ()})


class Vulnerability(ABC):
    """Object representing vulnerability."""

    def __init__(
        self,
        name="",
        cve_id="",
        payload_file="",
        response_file="",
        description="",
        credit="",
        url="",
    ):
        """Create Vulnerability object based in provided parameters."""
        self.name = name
        self.cve_id = cve_id
        self.payload_file = payload_file
        self.response_file = response_file
        self.description = description
        self.credit = credit
        self.url = url

    def __str__(self):
        """Return description of vulnerability."""
        if self.cve_id:
            cve_desc = " ({})".format(self.cve_id)
        else:
            cve_desc = ""
        desc = "{}{}: {}\nCredit: {}\nSee more at: {}\n".format(
            self.name,
            cve_desc,
            self.description.encode("utf-8"),
            self.credit.encode("utf-8"),
            self.url,
        )
        return desc

    @property
    def protocol(self):
        """Return protocol that is connected with this vulnerability."""
        proto_name = os.path.split(self.payload_file)[0]
        return {
            "coap": Protocol.CoAP,
            "mdns": Protocol.mDNS,
            "htcpcp": Protocol.HTCPCP,
            "http": Protocol.HTTP,
            "knx": Protocol.KNX,
            "mqtt": Protocol.MQTT,
            "rtsp": Protocol.RTSP,
            "ssdp": Protocol.SSDP,
            "dtls": Protocol.DTLS,
        }[proto_name]

    @abc.abstractmethod
    def verify(self, test_params):
        """Verify whether remote host is vulnerable to this vulnerability."""
        raise NotImplementedError()

    def report_positive_result(self, test_params):
        """Report positive result of vulnerability test."""
        test_params.test_stats.active_endpoints[self.protocol].append(
            "{}:{} - vuln: {}".format(
                test_params.dst_endpoint.ip_addr,
                test_params.dst_endpoint.port,
                self.name,
            )
        )

    def report_negative_result(self, test_params):
        """Report negative result of vulnerability test."""
        test_params.test_stats.inactive_endpoints[self.protocol].append(
            "{}:{}".format(
                test_params.dst_endpoint.ip_addr, test_params.dst_endpoint.port
            )
        )

    def report_potential_result(self, test_params):
        """Report potential result of vulnerability test."""
        test_params.test_stats.potential_endpoints[self.protocol].append(
            "{}:{} - vuln: {}".format(
                test_params.dst_endpoint.ip_addr,
                test_params.dst_endpoint.port,
                self.name,
            )
        )


def udp_sr(test_params, data, response_count=99999, protocol=CoAP):
    """Send data using UDP protocol and receive multiple responses."""
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

    if test_params.ip_version == 4:
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    elif test_params.ip_version == 6:
        sock = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)
    sock.settimeout(test_params.timeout_sec)
    request_size = len(data)
    response_size = 0
    dst_endpoint = test_params.dst_endpoint
    sock.sendto(data, (dst_endpoint.ip_addr, dst_endpoint.port))
    response = []
    try:
        for _ in range(response_count):
            in_data, server_addr = sock.recvfrom(INPUT_BUFFER_SIZE)
            response_size += len(in_data)
            response.append(in_data)
            packet = protocol(in_data)
            print_verbose(
                test_params,
                "Received packet size {} from {}\n{}".format(
                    len(in_data), server_addr, show_verbose(test_params, packet)
                ),
            )
    except socket.timeout:
        print_verbose(test_params, "Timeout")
    print_verbose(
        test_params,
        "Request size = {}".format(request_size + UDP_LOW_LAYERS_HEADERS_SIZE_IPV4),
    )
    print_verbose(
        test_params,
        "Response size = {}".format(response_size + UDP_LOW_LAYERS_HEADERS_SIZE_IPV4),
    )
    return response


class InformationDisclosure(Vulnerability):
    """Vulnerability leading to information disclosure."""

    def __init__(
        self, name, cve_id, payload_file, response_file, description, credit, url
    ):
        """Create InformationDisclosure object based in provided parameters."""
        Vulnerability.__init__(
            self,
            name=name,
            cve_id=cve_id,
            payload_file=payload_file,
            response_file=response_file,
            description=description,
            credit=credit,
            url=url,
        )

    def verify(self, test_params):
        """Verify whether remote host is vulnerable to this vulnerability."""
        alive_before = service_ping(test_params)
        if not alive_before:
            print_verbose(
                test_params,
                "[+] Server {}:{} is dead before sending payload".format(
                    test_params.dst_endpoint.ip_addr, test_params.dst_endpoint.port
                ),
            )
        if not alive_before and not test_params.ignore_ping_check:
            print(
                "[.] Vulnerability testing ({}) stopped for {}:{} because "
                "server is not responding to protocol {}\n"
                "    (use --ignore-ping-check if you"
                " want to continue anyway)!".format(
                    self.name,
                    test_params.dst_endpoint.ip_addr,
                    test_params.dst_endpoint.port,
                    test_params.protocol.name,
                )
            )
            return False
        test_result = sr1_file(test_params, VULN_DB_PATH + self.payload_file)
        print_verbose(test_params, "[*] Payload for {} sent".format(self.name))

        if test_result is not None:
            print_verbose(
                test_params, "[.] Received response:\n{}\n".format(test_result)
            )
            with open(VULN_DB_PATH + self.response_file, "rb") as file_handle:
                response_keyword = file_handle.read()
                if response_keyword in test_result:
                    self.report_positive_result(test_params)
                    print(
                        "[+] Server {}:{} is vulnerable to {}".format(
                            test_params.dst_endpoint.ip_addr,
                            test_params.dst_endpoint.port,
                            self.name,
                        )
                    )
                    return True
        self.report_negative_result(test_params)
        print(
            "[+] Server {}:{} is probably NOT vulnerable to {}".format(
                test_params.dst_endpoint.ip_addr,
                test_params.dst_endpoint.port,
                self.name,
            )
        )
        return False


class NetworkTrafficAmplification(Vulnerability):
    """Vulnerability leading to network traffic amplification."""

    def __init__(
        self,
        name,
        cve_id,
        payload_file,
        timeout_sec,
        nr_packets,
        description,
        credit,
        url,
    ):
        """Create NetworkTrafficAmplification object based in provided parameters."""
        Vulnerability.__init__(
            self,
            name=name,
            cve_id=cve_id,
            payload_file=payload_file,
            response_file="",
            description=description,
            credit=credit,
            url=url,
        )
        self.timeout_sec = timeout_sec
        self.nr_packets = nr_packets

    def verify(self, test_params):
        """Verify whether remote host is vulnerable to this vulnerability."""
        test_params.timeout_sec = self.timeout_sec
        test_payload = None
        with open(VULN_DB_PATH + self.payload_file, "rb") as file_handle:
            test_payload = file_handle.read()
        print(
            "[+] Vulnerability {} is network traffic amplification.\nAfter sending payload,"
            " tool is going to wait for {} sec to count size of response packets."
            "\n(Press CTRL-C to break)".format(self.name, self.timeout_sec)
        )
        try:
            response = udp_sr(
                test_params,
                test_payload,
                self.nr_packets,
                PROTOCOL_TESTERS[self.protocol].response_parser(),
            )
        except KeyError:
            return
        in_size = len(test_payload) + UDP_LOW_LAYERS_HEADERS_SIZE_IPV4
        out_size = sum(map(len, response)) + UDP_LOW_LAYERS_HEADERS_SIZE_IPV4 * len(
            response
        )
        amplify_factor = amplification_factor(in_size, out_size)
        print_verbose(
            test_params,
            "IN: {} bytes OUT: {} bytes AMPLIFICATION FACTOR: {:0.2f}%".format(
                in_size, out_size, amplify_factor
            ),
        )
        if amplify_factor > 100:
            result = ""
            self.report_positive_result(test_params)
        else:
            result = "NOT "
            self.report_negative_result(test_params)

        print(
            "[+] Server {}:{} is {}amplyfing traffic! "
            "AMPLIFICATION FACTOR: {:0.2f}%".format(
                test_params.dst_endpoint.ip_addr,
                test_params.dst_endpoint.port,
                result,
                amplify_factor,
            )
        )


class Crash(Vulnerability):
    """Object representing crash vulnerability."""

    def verify(self, test_params):
        """Verify whether remote host is vulnerable to this vulnerability."""
        alive_before = service_ping(test_params)
        if not alive_before:
            print_verbose(
                test_params,
                "[+] Server {}:{} is dead before sending payload".format(
                    test_params.dst_endpoint.ip_addr, test_params.dst_endpoint.port
                ),
            )
        if not alive_before and not test_params.ignore_ping_check:
            print(
                "[.] Vulnerability testing ({}) stopped for {}:{} because "
                "server is not responding\n    (use --ignore-ping-check if you"
                " want to continue anyway)!".format(
                    self.name,
                    test_params.dst_endpoint.ip_addr,
                    test_params.dst_endpoint.port,
                )
            )
            return
        test_result = sr1_file(test_params, VULN_DB_PATH + self.payload_file)
        print_verbose(test_params, "[*] Payload for {} sent".format(self.name))

        if test_result is not None:
            test_result_string = "NOT"
            if test_result is Packet:
                show_verbose(test_params, test_result)
            # else:
            #     print(test_result)
        else:
            test_result_string = "probably"
        alive_after = service_ping(test_params)
        if not alive_after:
            print_verbose(
                test_params,
                "[+] Server {}:{} is dead after sending payload".format(
                    test_params.dst_endpoint.ip_addr, test_params.dst_endpoint.port
                ),
            )
        if alive_before and not alive_after:
            test_result_string = "probably"
            self.report_positive_result(test_params)
        elif alive_after:
            test_result_string = "NOT"
            self.report_negative_result(test_params)

        if not alive_before and not alive_after:
            print(
                "[+] Server {}:{} was not responding to ping before sending "
                "payload, so you need to check result of test directly on "
                "tested device!".format(
                    test_params.dst_endpoint.ip_addr, test_params.dst_endpoint.port
                )
            )
            self.report_potential_result(test_params)
        else:
            print(
                "[+] Server {}:{} is {} vulnerable to {}".format(
                    test_params.dst_endpoint.ip_addr,
                    test_params.dst_endpoint.port,
                    test_result_string,
                    self.name,
                )
            )


class MemoryLeak(Vulnerability):
    """Object representing memory leak vulnerability."""

    def verify(self, test_params):
        """Verify whether remote host is vulnerable to this vulnerability."""
        test_result = sr1_file(test_params, VULN_DB_PATH + self.payload_file)
        print("[*] Payload for {} sent".format(self.name))
        if test_result is not None:
            if test_result is Packet:
                show_verbose(test_params, test_result)
        print(
            "[+] Vulnerability {} is memory leak - verify manually result of "
            "this test.".format(self.name)
        )
        self.report_potential_result(test_params)


def load_vulnerabilities(yaml_file_path):
    """Load list of vulnerabilities from external YAML file."""
    vulnerabilities = {}
    with open(yaml_file_path, "rb") as file_handle:
        vuln_db_content = file_handle.read()
        vuln_db_list = yaml.safe_load(vuln_db_content)
        for vuln_raw in vuln_db_list:
            if vuln_raw["type"] == "NetworkTrafficAmplification":
                vuln = globals()[vuln_raw["type"]](
                    name=vuln_raw["name"],
                    cve_id=vuln_raw["cve_id"],
                    payload_file=vuln_raw["payload_file"],
                    timeout_sec=vuln_raw["timeout_sec"],
                    nr_packets=vuln_raw["nr_packets"],
                    description=vuln_raw["description"],
                    credit=vuln_raw["credit"],
                    url=vuln_raw["url"],
                )
            elif vuln_raw["type"] == "InformationDisclosure":
                vuln = globals()[vuln_raw["type"]](
                    name=vuln_raw["name"],
                    cve_id=vuln_raw["cve_id"],
                    payload_file=vuln_raw["payload_file"],
                    response_file=vuln_raw["response_file"],
                    description=vuln_raw["description"],
                    credit=vuln_raw["credit"],
                    url=vuln_raw["url"],
                )
            elif vuln_raw["type"] in ["Crash", "MemoryLeak"]:
                vuln = globals()[vuln_raw["type"]](
                    name=vuln_raw["name"],
                    cve_id=vuln_raw["cve_id"],
                    payload_file=vuln_raw["payload_file"],
                    description=vuln_raw["description"],
                    credit=vuln_raw["credit"],
                    url=vuln_raw["url"],
                )
            vulnerabilities[vuln_raw["name"]] = vuln
    return vulnerabilities


VULNS = load_vulnerabilities(VULN_DB_YAML)
CVES = {}


def test_selected_cves(test_params, list_cves, vuln):
    """Test vulnerability of given name against server at given IP:port."""
    if set(list_cves).intersection(["ALL", vuln.name]):
        main_test_protocol = test_params.protocol
        test_params.protocol = vuln.protocol
        vuln.verify(test_params)
        test_params.protocol = main_test_protocol


def bypass_list(args):
    """Bypass standard processing if --list or -L options were used."""
    if "--list" in args or "-L" in args:
        print("Number of vulnerabilities in database: {}\n".format(len(VULNS)))
        vulns = list(VULNS)
        vulns.sort()
        for vuln in vulns:
            print(VULNS[vuln])
        sys.exit(0)


def perform_vuln_testing(test_params, vulnerabilities):
    """Perform vulnerability testing."""
    vulns = list(VULNS)
    vulns.sort()
    for vuln_name in vulns:
        if protocol_enabled(VULNS[vuln_name].protocol, test_params.protocol):
            test_selected_cves(test_params, vulnerabilities, VULNS[vuln_name])
        else:
            print_verbose(
                test_params,
                "Vulnerability {} skipped because of selection!".format(
                    VULNS[vuln_name].name
                ),
            )


def select_vulnerabilities(tester, args):
    """Provide list of vulnerabilities to test based on options provided by args."""
    list_vulns = list(VULNS)
    list_vulns.append("ALL")
    list_vulns.sort()

    for vuln_name in VULNS:
        if VULNS[vuln_name].cve_id:
            CVES[VULNS[vuln_name].cve_id] = VULNS[vuln_name]

    list_cves = list(CVES)
    list_cves.append("ALL")
    list_cves.sort()

    tester.argparser.add_argument(
        "--vuln",
        action="store",
        nargs="+",
        choices=list_vulns,
        default=["ALL"],
        help="list of vulnerabilities to be tested" " (by SOFT_NUM id)",
    )
    tester.argparser.add_argument(
        "--cve",
        action="store",
        nargs="+",
        choices=list_cves,
        default=["ALL"],
        help="list of vulnerabilities to be tested " "(by CVE id)",
    )
    tester.argparser.add_argument(
        "--list",
        "-L",
        action="store_true",
        help="display lists of all vulnerabilities supported by this tool"
        " with detailed description",
    )

    options = tester.parse_args(args)
    test_params = tester.test_params
    print_verbose(
        test_params, "selected vulnerabilities by cve: {}".format(options.cve)
    )
    print_verbose(
        test_params, "selected vulnerabilities by name: {}".format(options.vuln)
    )

    selected_vulns = options.vuln
    if "ALL" not in options.cve and "ALL" in selected_vulns:
        selected_vulns.remove("ALL")
    for cve in options.cve:
        if cve != "ALL" and CVES[cve].name not in selected_vulns:
            selected_vulns.append(CVES[cve].name)
    print_verbose(
        test_params, "merged selected vulns by name: {}".format(selected_vulns)
    )

    return selected_vulns


def main(args):
    """Start vulnerability testing based on command line parameters."""
    bypass_list(args)

    tester = CotopaxiTester(test_name="vulnerability testing", check_ignore_ping=True)
    tester.test_params.positive_result_name = "Vulnerable endpoints"
    tester.test_params.negative_result_name = "Invulnerable endpoints"

    selected_vulns = select_vulnerabilities(tester, args)

    tester.perform_testing(
        "vulnerability testing", perform_vuln_testing, selected_vulns
    )


if __name__ == "__main__":
    main(sys.argv[1:])
